#include<bits/stdc++.h>
using namespace std;
int n,m;
vector<int>tree;
int lowbit(int x)
{
    return x&(-x);
}
int query(int i)
{
    int sum=0;
    while(i>=1)
    {
        sum+=tree[i];
        i-=lowbit(i);
    }
    return sum;
}
void add(int i,int pos)
{
    while(i<=n)
    {
        tree[i]+=pos;
        i+=lowbit(i);
    }
}
int main()
{
    cin>>n>>m;
    tree.resize(n+1,0);
    for(int i=1;i<=n;i++)
        add(i,1);
    for(int i=1;i<=m;i++)
    {
        int t;
        cin>>t;
        cout<<query(t)<<' ';
        add(t,-1);
    }
}
/*
探寻能快速做到以下的数据结构
区间求和，区间修改，单点修改，单点求和，区间最大/最小值，区间第k小值

我们想要的的得到结果就必须要求和，修改改变的是求和的结果

优化的方向之一为避免重复计算

原始数组a[n+1] :单点修改，单点求和--->O(1)   区间求和，区间修改---->O(n)   区间最大/最小值--->O(n)  区间第k小值--->O(n*k)


静态区间求和数组（预处理后，避免重复运算）：单点求和，区间求和--->O(1)  单点修改,区间加减乘除修改--->O(n)
add[i](表示[1,i]的a元素的和)
在预处理后，
可以O(1)求出a的任一区间元素的和
如：[i,j]的和为add[j]-add[i-1]


区间加减修改数组(原理：修改区间内两数的差不变，只有区间两端与外界的差改变)：单点修改和区间加减修改---->O(1)  单点求和，区间求和--->O(n)
change[i](表示a[i]-a[i-1]) 存储相邻元素的数值差的信息   注：change[0]必须初始化为0
如：[i,j]区间元素增加p 则change[j+1]-=p change[i]+=p


如果要乘除修改的话，修改区间内的数的差会改变
还需要对[i,j]的change进行区间修改 ----->O(n)



区间加减修改数组---->原始数组a[n+1]------->静态区间求和数组


区间求和，就要利用一些预处理的数，这些数是按规则得到的区间和，这些规则区间经过加减一定能达到目标区间，   //高效率要求经行的运算次数要少
区间修改，就是对与目标区间相交的规则区间的和进行修改，                                               //高效率要求与目标区间相交的规则区间要少
1.一定能达到目标区间要求规则区间的精确度最小不能大于一
2.与目标区间相交的规则区间要少要求运算不能全为减法
3.运算较少要求存在长度较大的区间

线段树：区间每次都分两半
这种树有log2(n)层，节点数



































































对前缀和数组进行优化：
普通前缀和：直接是1——i的前缀，这样求前缀和较快，但是目标点与前缀区间相交较多，单点修改较慢

要想相交减少，1——i的前缀就要进行合理切割。












































树状数组：
求n的前缀和，用2^i+2^j+2^k.........得到
具体为以下区间之和
(1——2^i) + (2^i+1——2^i+2^j) + ......+(2^i+2^j+2^k....)   

i,j,k的选取
2^i<=n<2^i+1  2^i+2^j<=n<2^i + 2^j+1 接下来的同理

(2^i+2^j+2^k....)=n 且i>j>k>....   


如19=1——16+17——18+19
tree[i]=[i-i的最低位的大小+1，i]的原数组和
构建树状数组---->相当于原数组初始化为0，对1——n依次经行单点修改
单点修改：
若修改a[i],则对tree[j](j<i)没影响，对tree[k]（k-最低位+1<=i）有影响

k=i+p

则i+p-最低位+1<=i
p+1<=最低位(加p后的)
若p<最低位
则p比现在的最低位小，式子一定不成立
若p大于最低位，式子也不成立
故每次都加最低位，直到超过界限

1 1
2 1——2
3 3 
4 1——4
5 5
6 5——6
7 7
8 1——8
9 9
10 9——10
11 11
12 9——12
13 13——13
14











利用树状数组求前缀和的方法
19=10011 最小位为1,tree[19]=[19-1+1,19]的原数组和
然后19-1=18=10010 最小位为2 tree[18]=[18-2+1,18]的原数组和
18-2=16=10000 最小位为16 tree[16]=[16-16+1,16]的原数组和
16-16=0,结束
























应用：
单点修改，单点求和：原始数组





区间求和，区间修改：





区间求和，单点求和：静态区间求和数组


区间求和，单点修改:
树状数组



区间修改，单点修改:差分数组




区间修改，单点求和:

可以通过差分数组转化 区间修改转化为单点修改，单点求和转化为区间求和--->区间求和，单点修改:






















































原始数组，区间修改数组和静态区间求和数组都是同一种逻辑关系的不同表现形式



































静态区间求和问题：区间求和







动态区间求和问题:单点修改后，区间求和

一个询问是单点修改后，区间求和的话，需要对add数组的修改点到最后点都进行修改再求和
n个询问为O(n2);





树状数组 :动态前缀和问题:单点修改后，区间求和
1 1
2 1-2
3 2-3
4 1-4
5 4-5
6 4-6
7

*/